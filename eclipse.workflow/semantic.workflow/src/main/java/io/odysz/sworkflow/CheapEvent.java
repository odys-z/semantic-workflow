package io.odysz.sworkflow;

import java.util.ArrayList;

import io.odysz.semantics.SemanticObject;
import io.odysz.sworkflow.EnginDesign.Req;

public class CheapEvent {
	public enum Evtype { arrive, start, step, close }

	@Override
	public String toString() {
		return String.format("CheapEvent wf: %s, currentNodeId: %s, nextNodeId: %s, instId: %s, taskId: %s, cmd: %s",
				wfId, currentNodeId, nextNodeId, instId, taskId, cmd);
	}

	private String wfId;
	private Evtype etype;
	private CheapNode currentNodeId;
	private CheapNode nextNodeId;
//	private String prevNodes;
	private String instId;
	private String taskId;
	private Req cmd;

	/**When this is creating by cheap engine, there is not node instance id.
	 * After sqls be committed, resolve it from semantext.
	 * @param wfId workflow id/type
	 * @param evt event type
	 * @param current current node id
	 * @param next
	 * @param prevNs previous nodes
	 * @param taskId
	 * @param rq
	 */
	public CheapEvent(String wfId, Evtype evt, CheapNode current,
			CheapNode next, String taskId, Req rq) {
		this.wfId = wfId;
		this.etype = evt;
		this.currentNodeId = current;
		this.nextNodeId = next;
		// this.instId = instid;
		// this.prevNodes = next.prevNodes();
		this.taskId = taskId;
		this.cmd = rq;
	}

//	public CheapEvent(String wfId, String nodeId, String nextId, String taskId, Req req) {
//		// TODO Auto-generated constructor stub
//	}

	public String wfId() {
		return wfId;
	}

	public CheapNode currentNodeId() {
		return currentNodeId;
	}

	public CheapNode nextNodeId() {
		return nextNodeId;
	}

	public String instId() {
		return instId;
	}

	public String taskId() {
		return taskId;
	}

	public Req cmd() {
		return cmd;
	}

	/**When starting a new task, it must committed when the task id can be retrieved.<br>
	 * Sometimes the event is figured out by engine on a new starting task.<br>
	 * This needing new task ID (generated by DB) been resolved for the event.
	 * @param newIds
	 */
	@SuppressWarnings("unchecked")
	public void resolveTaskId(SemanticObject newIds) {
		if (taskId == null || taskId.startsWith("AUTO"))
			taskId = taskId.replaceAll("^\\s*AUTO", ((ArrayList<String>) newIds.get("rows")).get(0));
	}

//	public boolean isStarting(String wftype) {
//		return wfId.equals(wftype)
//			&& currentNodeId.matches(wftype + CheapWorkflow.virtNodeSuffix);
//	}

//	public String prevNodes() { return prevNodes; }

	public String evtype() { return etype.name(); }
}
