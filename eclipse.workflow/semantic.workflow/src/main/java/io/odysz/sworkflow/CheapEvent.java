package io.odysz.sworkflow;

import java.util.ArrayList;

import io.odysz.semantics.SemanticObject;
import io.odysz.sworkflow.EnginDesign.Req;

public class CheapEvent {
	public enum Evtype {
		arrive
	}

	@Override
	public String toString() {
		return String.format("CheapEvent wf: %s, currentNodeId: %s, nextNodeId: %s, instId: %s, taskId: %s, cmd: %s",
				wfId, currentNodeId, nextNodeId, instId, taskId, cmd);
	}

	private String wfId;
	private String currentNodeId;
	private String nextNodeId;
	private String instId;
	private String taskId;
	private Req cmd;

	public CheapEvent(String wfId, String currentNode, String nextNode, String instid, String taskId, Req req) {
		this.wfId = wfId;
		this.currentNodeId = currentNode;
		this.nextNodeId = nextNode;
		this.instId = instid;
		this.taskId = taskId;
		this.cmd = req;
	}

	public String wfId() {
		return wfId;
	}

	public String currentNodeId() {
		return currentNodeId;
	}

	public String nextNodeId() {
		return nextNodeId;
	}

	public String instId() {
		return instId;
	}

	public String taskId() {
		return taskId;
	}

	public Req cmd() {
		return cmd;
	}

	/**When starting a new task, it must committed when the task id can be retrieved.<br>
	 * Sometimes the event is figured out by engine on a new starting task.<br>
	 * This needing new task ID (generated by DB) been resolved for the event.
	 * @param newIds
	 */
	@SuppressWarnings("unchecked")
	public void resolveTaskId(SemanticObject newIds) {
		if (taskId == null || taskId.startsWith("AUTO"))
			taskId = taskId.replaceAll("^\\s*AUTO", ((ArrayList<String>) newIds.get("rows")).get(0));
	}

	public boolean isStarting(String wftype) {
		return wfId.equals(wftype)
			&& currentNodeId.matches(wftype + CheapWorkflow.virtNodeSuffix);
	}

}
